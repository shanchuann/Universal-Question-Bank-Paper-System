/* tslint:disable */
/* eslint-disable */
/**
 * Generalized Exam Item Bank & Paper Generation API
 * REST contract for RBAC-secured question management, paper assembly, online examination, and analytics services powering the Universal Question Bank Paper System.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthTokenResponse
 */
export interface AuthTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthTokenResponse
     */
    'expiresIn'?: number;
}
/**
 * 
 * @export
 * @interface AutoPaperCreateRequest
 */
export interface AutoPaperCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoPaperCreateRequest
     */
    'subjectId': string;
    /**
     * 
     * @type {string}
     * @memberof AutoPaperCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequest
     */
    'durationMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequest
     */
    'totalScore': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoPaperCreateRequest
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AutoPaperCreateRequest
     */
    'typeRatio': { [key: string]: number; };
    /**
     * 
     * @type {AutoPaperCreateRequestDifficultyDistribution}
     * @memberof AutoPaperCreateRequest
     */
    'difficultyDistribution': AutoPaperCreateRequestDifficultyDistribution;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoPaperCreateRequest
     */
    'exclusions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AutoPaperCreateRequestDifficultyDistribution
 */
export interface AutoPaperCreateRequestDifficultyDistribution {
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequestDifficultyDistribution
     */
    'EASY'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequestDifficultyDistribution
     */
    'MEDIUM'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequestDifficultyDistribution
     */
    'HARD'?: number;
}
/**
 * 
 * @export
 * @interface AutosaveRequest
 */
export interface AutosaveRequest {
    /**
     * 
     * @type {number}
     * @memberof AutosaveRequest
     */
    'sequence': number;
    /**
     * Snapshot of answers keyed by questionId.
     * @type {object}
     * @memberof AutosaveRequest
     */
    'payload': object;
    /**
     * 
     * @type {string}
     * @memberof AutosaveRequest
     */
    'clientTimestamp'?: string;
}
/**
 * 
 * @export
 * @interface ExamAnalyticsResponse
 */
export interface ExamAnalyticsResponse {
    /**
     * 
     * @type {string}
     * @memberof ExamAnalyticsResponse
     */
    'paperVersionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamAnalyticsResponse
     */
    'averageScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamAnalyticsResponse
     */
    'highestScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamAnalyticsResponse
     */
    'passRate'?: number;
    /**
     * 
     * @type {Array<ScoreBucket>}
     * @memberof ExamAnalyticsResponse
     */
    'scoreDistribution'?: Array<ScoreBucket>;
    /**
     * 
     * @type {Array<KnowledgeMetric>}
     * @memberof ExamAnalyticsResponse
     */
    'knowledgeMastery'?: Array<KnowledgeMetric>;
    /**
     * 
     * @type {Array<QuestionErrorRate>}
     * @memberof ExamAnalyticsResponse
     */
    'errorRates'?: Array<QuestionErrorRate>;
}
/**
 * 
 * @export
 * @interface ExamQuestion
 */
export interface ExamQuestion {
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'questionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'stem'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof ExamQuestion
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'userAnswer'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'awardedScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'graderNotes'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExamQuestion
     */
    'isCorrect'?: boolean;
}
/**
 * 
 * @export
 * @interface ExamSessionPage
 */
export interface ExamSessionPage {
    /**
     * 
     * @type {Array<ExamSessionResponse>}
     * @memberof ExamSessionPage
     */
    'content'?: Array<ExamSessionResponse>;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface ExamSessionResponse
 */
export interface ExamSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'paperVersionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionResponse
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'startAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'endAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionResponse
     */
    'timeRemainingSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionResponse
     */
    'autosaveIntervalSeconds'?: number;
    /**
     * 
     * @type {Array<ExamQuestion>}
     * @memberof ExamSessionResponse
     */
    'questions'?: Array<ExamQuestion>;
}
/**
 * 
 * @export
 * @interface KnowledgeMetric
 */
export interface KnowledgeMetric {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeMetric
     */
    'knowledgePointId'?: string;
    /**
     * 
     * @type {number}
     * @memberof KnowledgeMetric
     */
    'masteryPercent'?: number;
    /**
     * Same as masteryPercent but as decimal (0-1)
     * @type {number}
     * @memberof KnowledgeMetric
     */
    'masteryRate'?: number;
}
/**
 * 
 * @export
 * @interface KnowledgePoint
 */
export interface KnowledgePoint {
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'parentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof KnowledgePoint
     */
    'sortOrder'?: number;
    /**
     * 
     * @type {Array<KnowledgePoint>}
     * @memberof KnowledgePoint
     */
    'children'?: Array<KnowledgePoint>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ManualGradeRequest
 */
export interface ManualGradeRequest {
    /**
     * 
     * @type {Array<ManualGradeRequestGrades>}
     * @memberof ManualGradeRequest
     */
    'grades': Array<ManualGradeRequestGrades>;
}
/**
 * 
 * @export
 * @interface ManualGradeRequestGrades
 */
export interface ManualGradeRequestGrades {
    /**
     * 
     * @type {string}
     * @memberof ManualGradeRequestGrades
     */
    'questionId': string;
    /**
     * 
     * @type {number}
     * @memberof ManualGradeRequestGrades
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof ManualGradeRequestGrades
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface ManualPaperCreateRequest
 */
export interface ManualPaperCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManualPaperCreateRequest
     */
    'subjectId': string;
    /**
     * 
     * @type {string}
     * @memberof ManualPaperCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperCreateRequest
     */
    'durationMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperCreateRequest
     */
    'totalScore'?: number;
    /**
     * 
     * @type {Array<ManualPaperQuestion>}
     * @memberof ManualPaperCreateRequest
     */
    'questions': Array<ManualPaperQuestion>;
}
/**
 * 
 * @export
 * @interface ManualPaperQuestion
 */
export interface ManualPaperQuestion {
    /**
     * 
     * @type {string}
     * @memberof ManualPaperQuestion
     */
    'questionId': string;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperQuestion
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperQuestion
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface PaperPublishRequest
 */
export interface PaperPublishRequest {
    /**
     * 
     * @type {string}
     * @memberof PaperPublishRequest
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof PaperPublishRequest
     */
    'activationStart': string;
    /**
     * 
     * @type {string}
     * @memberof PaperPublishRequest
     */
    'activationEnd': string;
    /**
     * 
     * @type {number}
     * @memberof PaperPublishRequest
     */
    'maxAttempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperPublishRequest
     */
    'autoSubmitGraceSeconds'?: number;
}
/**
 * 
 * @export
 * @interface PaperQuestionDetail
 */
export interface PaperQuestionDetail {
    /**
     * 
     * @type {string}
     * @memberof PaperQuestionDetail
     */
    'questionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaperQuestionDetail
     */
    'questionVersionNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperQuestionDetail
     */
    'position'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperQuestionDetail
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaperQuestionDetail
     */
    'difficulty'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaperQuestionDetail
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PaperVersionPage
 */
export interface PaperVersionPage {
    /**
     * 
     * @type {Array<PaperVersionResponse>}
     * @memberof PaperVersionPage
     */
    'content'?: Array<PaperVersionResponse>;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface PaperVersionResponse
 */
export interface PaperVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof PaperVersionResponse
     */
    'paperId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaperVersionResponse
     */
    'versionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaperVersionResponse
     */
    'assemblyMode'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'mtSeed'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'totalScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'durationMinutes'?: number;
    /**
     * 
     * @type {Array<PaperQuestionDetail>}
     * @memberof PaperVersionResponse
     */
    'questions'?: Array<PaperQuestionDetail>;
}
/**
 * 
 * @export
 * @interface QuestionCreateRequest
 */
export interface QuestionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'subjectId': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'type': QuestionCreateRequestTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'stem': string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionCreateRequest
     */
    'options'?: Array<QuestionOption>;
    /**
     * Machine-readable answer definition.
     * @type {object}
     * @memberof QuestionCreateRequest
     */
    'answerSchema': object;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'difficulty': QuestionCreateRequestDifficultyEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionCreateRequest
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof QuestionCreateRequest
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'mediaBundleId'?: string;
}

export const QuestionCreateRequestTypeEnum = {
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    MultipleChoice: 'MULTIPLE_CHOICE',
    TrueFalse: 'TRUE_FALSE',
    FillBlank: 'FILL_BLANK',
    ShortAnswer: 'SHORT_ANSWER'
} as const;

export type QuestionCreateRequestTypeEnum = typeof QuestionCreateRequestTypeEnum[keyof typeof QuestionCreateRequestTypeEnum];
export const QuestionCreateRequestDifficultyEnum = {
    Easy: 'EASY',
    Medium: 'MEDIUM',
    Hard: 'HARD'
} as const;

export type QuestionCreateRequestDifficultyEnum = typeof QuestionCreateRequestDifficultyEnum[keyof typeof QuestionCreateRequestDifficultyEnum];

/**
 * 
 * @export
 * @interface QuestionErrorRate
 */
export interface QuestionErrorRate {
    /**
     * 
     * @type {string}
     * @memberof QuestionErrorRate
     */
    'questionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'attempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'incorrect'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'errorRate'?: number;
    /**
     * Alias for incorrect
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'errorCount'?: number;
    /**
     * Alias for attempts
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'totalAttempts'?: number;
}
/**
 * 
 * @export
 * @interface QuestionOption
 */
export interface QuestionOption {
    /**
     * 
     * @type {string}
     * @memberof QuestionOption
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionOption
     */
    'text'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionOption
     */
    'isCorrect'?: boolean;
}
/**
 * 
 * @export
 * @interface QuestionPage
 */
export interface QuestionPage {
    /**
     * 
     * @type {Array<QuestionSummary>}
     * @memberof QuestionPage
     */
    'content'?: Array<QuestionSummary>;
    /**
     * 
     * @type {number}
     * @memberof QuestionPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface QuestionResponse
 */
export interface QuestionResponse {
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'subjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'stem'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'difficulty'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionResponse
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionResponse
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * JSON string of options array
     * @type {string}
     * @memberof QuestionResponse
     */
    'optionsJson'?: string;
    /**
     * 
     * @type {object}
     * @memberof QuestionResponse
     */
    'answerSchema'?: object;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'reviewNotes'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionResponse
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'reviewer'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionResponse
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {Array<QuestionRevision>}
     * @memberof QuestionResponse
     */
    'history'?: Array<QuestionRevision>;
}
/**
 * 
 * @export
 * @interface QuestionResponseAllOf
 */
export interface QuestionResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseAllOf
     */
    'stem'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionResponseAllOf
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {object}
     * @memberof QuestionResponseAllOf
     */
    'answerSchema'?: object;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseAllOf
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseAllOf
     */
    'reviewer'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionResponseAllOf
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {Array<QuestionRevision>}
     * @memberof QuestionResponseAllOf
     */
    'history'?: Array<QuestionRevision>;
}
/**
 * 
 * @export
 * @interface QuestionReviewRequest
 */
export interface QuestionReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionReviewRequest
     */
    'action': QuestionReviewRequestActionEnum;
    /**
     * 
     * @type {string}
     * @memberof QuestionReviewRequest
     */
    'notes'?: string;
}

export const QuestionReviewRequestActionEnum = {
    Approve: 'APPROVE',
    Reject: 'REJECT'
} as const;

export type QuestionReviewRequestActionEnum = typeof QuestionReviewRequestActionEnum[keyof typeof QuestionReviewRequestActionEnum];

/**
 * 
 * @export
 * @interface QuestionRevision
 */
export interface QuestionRevision {
    /**
     * 
     * @type {number}
     * @memberof QuestionRevision
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionRevision
     */
    'changedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionRevision
     */
    'changedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionRevision
     */
    'diffSummary'?: string;
}
/**
 * 
 * @export
 * @interface QuestionSummary
 */
export interface QuestionSummary {
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'subjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'stem'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'difficulty'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionSummary
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionSummary
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * JSON string of options array
     * @type {string}
     * @memberof QuestionSummary
     */
    'optionsJson'?: string;
    /**
     * Answer (e.g., \"A\" or \"A,B\")
     * @type {string}
     * @memberof QuestionSummary
     */
    'answerSchema'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'reviewNotes'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface QuestionUpdateRequest
 */
export interface QuestionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'subjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'stem'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionUpdateRequest
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {object}
     * @memberof QuestionUpdateRequest
     */
    'answerSchema'?: object;
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'difficulty'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionUpdateRequest
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof QuestionUpdateRequest
     */
    'score'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionUpdateRequest
     */
    'versionNumber'?: number;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ScoreBucket
 */
export interface ScoreBucket {
    /**
     * 
     * @type {string}
     * @memberof ScoreBucket
     */
    'range'?: string;
    /**
     * Display label for the range
     * @type {string}
     * @memberof ScoreBucket
     */
    'rangeLabel'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreBucket
     */
    'percentage'?: number;
    /**
     * Number of students in this range
     * @type {number}
     * @memberof ScoreBucket
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SubmissionResponse
 */
export interface SubmissionResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'submittedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof SubmissionResponse
     */
    'objectiveScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmissionResponse
     */
    'totalScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'status'?: SubmissionResponseStatusEnum;
}

export const SubmissionResponseStatusEnum = {
    Submitted: 'SUBMITTED',
    Timeout: 'TIMEOUT'
} as const;

export type SubmissionResponseStatusEnum = typeof SubmissionResponseStatusEnum[keyof typeof SubmissionResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserCreateRequest
 */
export interface UserCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCreateRequest
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserPage
 */
export interface UserPage {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof UserPage
     */
    'content'?: Array<UserResponse>;
    /**
     * 
     * @type {number}
     * @memberof UserPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponse
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List users with filtering options (admin only).
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
         * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet: async (page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create user with role assignments.
         * @param {UserCreateRequest} userCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost: async (userCreateRequest: UserCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateRequest' is not null or undefined
            assertParamExists('apiUsersPost', 'userCreateRequest', userCreateRequest)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List users with filtering options (admin only).
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
         * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGet(page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGet(page, size, role, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create user with role assignments.
         * @param {UserCreateRequest} userCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersPost(userCreateRequest: UserCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersPost(userCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary List users with filtering options (admin only).
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
         * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options?: any): AxiosPromise<UserPage> {
            return localVarFp.apiUsersGet(page, size, role, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create user with role assignments.
         * @param {UserCreateRequest} userCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(userCreateRequest: UserCreateRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.apiUsersPost(userCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary List users with filtering options (admin only).
     * @param {number} [page] Zero-based page index.
     * @param {number} [size] Page size.
     * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
     * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiUsersGet(page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiUsersGet(page, size, role, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create user with role assignments.
     * @param {UserCreateRequest} userCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiUsersPost(userCreateRequest: UserCreateRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiUsersPost(userCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
         * @param {string} paperVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsExamsPaperVersionIdSummaryGet: async (paperVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paperVersionId' is not null or undefined
            assertParamExists('apiAnalyticsExamsPaperVersionIdSummaryGet', 'paperVersionId', paperVersionId)
            const localVarPath = `/api/analytics/exams/{paperVersionId}/summary`
                .replace(`{${"paperVersionId"}}`, encodeURIComponent(String(paperVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compute top N questions by error rate across selected timeframe.
         * @param {string} [subjectId] 
         * @param {string} [knowledgePointId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsQuestionsErrorRateGet: async (subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/analytics/questions/error-rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            if (knowledgePointId !== undefined) {
                localVarQueryParameter['knowledgePointId'] = knowledgePointId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
         * @param {string} paperVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsExamsPaperVersionIdSummaryGet(paperVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsExamsPaperVersionIdSummaryGet(paperVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Compute top N questions by error rate across selected timeframe.
         * @param {string} [subjectId] 
         * @param {string} [knowledgePointId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAnalyticsQuestionsErrorRateGet(subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionErrorRate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAnalyticsQuestionsErrorRateGet(subjectId, knowledgePointId, startDate, endDate, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
         * @param {string} paperVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsExamsPaperVersionIdSummaryGet(paperVersionId: string, options?: any): AxiosPromise<ExamAnalyticsResponse> {
            return localVarFp.apiAnalyticsExamsPaperVersionIdSummaryGet(paperVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compute top N questions by error rate across selected timeframe.
         * @param {string} [subjectId] 
         * @param {string} [knowledgePointId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAnalyticsQuestionsErrorRateGet(subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options?: any): AxiosPromise<Array<QuestionErrorRate>> {
            return localVarFp.apiAnalyticsQuestionsErrorRateGet(subjectId, knowledgePointId, startDate, endDate, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
     * @param {string} paperVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsExamsPaperVersionIdSummaryGet(paperVersionId: string, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsExamsPaperVersionIdSummaryGet(paperVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compute top N questions by error rate across selected timeframe.
     * @param {string} [subjectId] 
     * @param {string} [knowledgePointId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public apiAnalyticsQuestionsErrorRateGet(subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).apiAnalyticsQuestionsErrorRateGet(subjectId, knowledgePointId, startDate, endDate, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate user via username/password.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('apiAuthLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh JWT access token.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthTokenRefreshPost: async (refreshTokenRequest: RefreshTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('apiAuthTokenRefreshPost', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/api/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate user via username/password.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthLoginPost(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthLoginPost(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh JWT access token.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthTokenRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthTokenRefreshPost(refreshTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate user via username/password.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthLoginPost(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthTokenResponse> {
            return localVarFp.apiAuthLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh JWT access token.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthTokenRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: any): AxiosPromise<AuthTokenResponse> {
            return localVarFp.apiAuthTokenRefreshPost(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate user via username/password.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthLoginPost(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh JWT access token.
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiAuthTokenRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiAuthTokenRefreshPost(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExamApi - axios parameter creator
 * @export
 */
export const ExamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Validate access code and start exam session.
         * @param {string} accessCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsAccessCodeStartPost: async (accessCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessCode' is not null or undefined
            assertParamExists('apiExamsAccessCodeStartPost', 'accessCode', accessCode)
            const localVarPath = `/api/exams/{accessCode}/start`
                .replace(`{${"accessCode"}}`, encodeURIComponent(String(accessCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List exam sessions (for grading).
         * @param {string} [paperId] 
         * @param {string} [userId] 
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsGet: async (paperId?: string, userId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/exams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paperId !== undefined) {
                localVarQueryParameter['paperId'] = paperId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get exam session details.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExamsIdGet', 'id', id)
            const localVarPath = `/api/exams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Persist autosave snapshot (30s cadence).
         * @param {string} sessionId 
         * @param {AutosaveRequest} autosaveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdAutosavePost: async (sessionId: string, autosaveRequest: AutosaveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiExamsSessionIdAutosavePost', 'sessionId', sessionId)
            // verify required parameter 'autosaveRequest' is not null or undefined
            assertParamExists('apiExamsSessionIdAutosavePost', 'autosaveRequest', autosaveRequest)
            const localVarPath = `/api/exams/{sessionId}/autosave`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autosaveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record manual grades for subjective questions.
         * @param {string} sessionId 
         * @param {ManualGradeRequest} manualGradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdGradePost: async (sessionId: string, manualGradeRequest: ManualGradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiExamsSessionIdGradePost', 'sessionId', sessionId)
            // verify required parameter 'manualGradeRequest' is not null or undefined
            assertParamExists('apiExamsSessionIdGradePost', 'manualGradeRequest', manualGradeRequest)
            const localVarPath = `/api/exams/{sessionId}/grade`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualGradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Maintain active session and sync time remaining.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdHeartbeatPost: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiExamsSessionIdHeartbeatPost', 'sessionId', sessionId)
            const localVarPath = `/api/exams/{sessionId}/heartbeat`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit exam (voluntary or timeout).
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdSubmitPost: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiExamsSessionIdSubmitPost', 'sessionId', sessionId)
            const localVarPath = `/api/exams/{sessionId}/submit`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamApi - functional programming interface
 * @export
 */
export const ExamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Validate access code and start exam session.
         * @param {string} accessCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsAccessCodeStartPost(accessCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsAccessCodeStartPost(accessCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List exam sessions (for grading).
         * @param {string} [paperId] 
         * @param {string} [userId] 
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsGet(paperId?: string, userId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamSessionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsGet(paperId, userId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get exam session details.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Persist autosave snapshot (30s cadence).
         * @param {string} sessionId 
         * @param {AutosaveRequest} autosaveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsSessionIdAutosavePost(sessionId: string, autosaveRequest: AutosaveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsSessionIdAutosavePost(sessionId, autosaveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record manual grades for subjective questions.
         * @param {string} sessionId 
         * @param {ManualGradeRequest} manualGradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsSessionIdGradePost(sessionId: string, manualGradeRequest: ManualGradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsSessionIdGradePost(sessionId, manualGradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Maintain active session and sync time remaining.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsSessionIdHeartbeatPost(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsSessionIdHeartbeatPost(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit exam (voluntary or timeout).
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExamsSessionIdSubmitPost(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExamsSessionIdSubmitPost(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExamApi - factory interface
 * @export
 */
export const ExamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamApiFp(configuration)
    return {
        /**
         * 
         * @summary Validate access code and start exam session.
         * @param {string} accessCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsAccessCodeStartPost(accessCode: string, options?: any): AxiosPromise<ExamSessionResponse> {
            return localVarFp.apiExamsAccessCodeStartPost(accessCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List exam sessions (for grading).
         * @param {string} [paperId] 
         * @param {string} [userId] 
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsGet(paperId?: string, userId?: string, page?: number, size?: number, options?: any): AxiosPromise<ExamSessionPage> {
            return localVarFp.apiExamsGet(paperId, userId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get exam session details.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsIdGet(id: string, options?: any): AxiosPromise<ExamSessionResponse> {
            return localVarFp.apiExamsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Persist autosave snapshot (30s cadence).
         * @param {string} sessionId 
         * @param {AutosaveRequest} autosaveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdAutosavePost(sessionId: string, autosaveRequest: AutosaveRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiExamsSessionIdAutosavePost(sessionId, autosaveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record manual grades for subjective questions.
         * @param {string} sessionId 
         * @param {ManualGradeRequest} manualGradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdGradePost(sessionId: string, manualGradeRequest: ManualGradeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiExamsSessionIdGradePost(sessionId, manualGradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Maintain active session and sync time remaining.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdHeartbeatPost(sessionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiExamsSessionIdHeartbeatPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit exam (voluntary or timeout).
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExamsSessionIdSubmitPost(sessionId: string, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.apiExamsSessionIdSubmitPost(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamApi - object-oriented interface
 * @export
 * @class ExamApi
 * @extends {BaseAPI}
 */
export class ExamApi extends BaseAPI {
    /**
     * 
     * @summary Validate access code and start exam session.
     * @param {string} accessCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsAccessCodeStartPost(accessCode: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsAccessCodeStartPost(accessCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List exam sessions (for grading).
     * @param {string} [paperId] 
     * @param {string} [userId] 
     * @param {number} [page] Zero-based page index.
     * @param {number} [size] Page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsGet(paperId?: string, userId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsGet(paperId, userId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get exam session details.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsIdGet(id: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Persist autosave snapshot (30s cadence).
     * @param {string} sessionId 
     * @param {AutosaveRequest} autosaveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsSessionIdAutosavePost(sessionId: string, autosaveRequest: AutosaveRequest, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsSessionIdAutosavePost(sessionId, autosaveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record manual grades for subjective questions.
     * @param {string} sessionId 
     * @param {ManualGradeRequest} manualGradeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsSessionIdGradePost(sessionId: string, manualGradeRequest: ManualGradeRequest, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsSessionIdGradePost(sessionId, manualGradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Maintain active session and sync time remaining.
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsSessionIdHeartbeatPost(sessionId: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsSessionIdHeartbeatPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit exam (voluntary or timeout).
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public apiExamsSessionIdSubmitPost(sessionId: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).apiExamsSessionIdSubmitPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KnowledgePointApi - axios parameter creator
 * @export
 */
export const KnowledgePointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all knowledge points as a tree structure.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/knowledge-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a knowledge point.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKnowledgePointsIdDelete', 'id', id)
            const localVarPath = `/api/knowledge-points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a knowledge point.
         * @param {string} id 
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsIdPut: async (id: string, knowledgePoint: KnowledgePoint, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKnowledgePointsIdPut', 'id', id)
            // verify required parameter 'knowledgePoint' is not null or undefined
            assertParamExists('apiKnowledgePointsIdPut', 'knowledgePoint', knowledgePoint)
            const localVarPath = `/api/knowledge-points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(knowledgePoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new knowledge point.
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsPost: async (knowledgePoint: KnowledgePoint, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'knowledgePoint' is not null or undefined
            assertParamExists('apiKnowledgePointsPost', 'knowledgePoint', knowledgePoint)
            const localVarPath = `/api/knowledge-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(knowledgePoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgePointApi - functional programming interface
 * @export
 */
export const KnowledgePointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgePointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all knowledge points as a tree structure.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKnowledgePointsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KnowledgePoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKnowledgePointsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a knowledge point.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKnowledgePointsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKnowledgePointsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a knowledge point.
         * @param {string} id 
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKnowledgePointsIdPut(id: string, knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKnowledgePointsIdPut(id, knowledgePoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new knowledge point.
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKnowledgePointsPost(knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKnowledgePointsPost(knowledgePoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KnowledgePointApi - factory interface
 * @export
 */
export const KnowledgePointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgePointApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all knowledge points as a tree structure.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsGet(options?: any): AxiosPromise<Array<KnowledgePoint>> {
            return localVarFp.apiKnowledgePointsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a knowledge point.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiKnowledgePointsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a knowledge point.
         * @param {string} id 
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsIdPut(id: string, knowledgePoint: KnowledgePoint, options?: any): AxiosPromise<KnowledgePoint> {
            return localVarFp.apiKnowledgePointsIdPut(id, knowledgePoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new knowledge point.
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKnowledgePointsPost(knowledgePoint: KnowledgePoint, options?: any): AxiosPromise<KnowledgePoint> {
            return localVarFp.apiKnowledgePointsPost(knowledgePoint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KnowledgePointApi - object-oriented interface
 * @export
 * @class KnowledgePointApi
 * @extends {BaseAPI}
 */
export class KnowledgePointApi extends BaseAPI {
    /**
     * 
     * @summary Get all knowledge points as a tree structure.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public apiKnowledgePointsGet(options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).apiKnowledgePointsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a knowledge point.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public apiKnowledgePointsIdDelete(id: string, options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).apiKnowledgePointsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a knowledge point.
     * @param {string} id 
     * @param {KnowledgePoint} knowledgePoint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public apiKnowledgePointsIdPut(id: string, knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).apiKnowledgePointsIdPut(id, knowledgePoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new knowledge point.
     * @param {KnowledgePoint} knowledgePoint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public apiKnowledgePointsPost(knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).apiKnowledgePointsPost(knowledgePoint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaperApi - axios parameter creator
 * @export
 */
export const PaperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate paper via MT19937-driven auto assembly.
         * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersAutoPost: async (autoPaperCreateRequest: AutoPaperCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoPaperCreateRequest' is not null or undefined
            assertParamExists('apiPapersAutoPost', 'autoPaperCreateRequest', autoPaperCreateRequest)
            const localVarPath = `/api/papers/auto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoPaperCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create manual paper draft and attach selected questions.
         * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersManualPost: async (manualPaperCreateRequest: ManualPaperCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manualPaperCreateRequest' is not null or undefined
            assertParamExists('apiPapersManualPost', 'manualPaperCreateRequest', manualPaperCreateRequest)
            const localVarPath = `/api/papers/manual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualPaperCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish paper version with activation window.
         * @param {string} paperId 
         * @param {PaperPublishRequest} paperPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersPaperIdPublishPost: async (paperId: string, paperPublishRequest: PaperPublishRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paperId' is not null or undefined
            assertParamExists('apiPapersPaperIdPublishPost', 'paperId', paperId)
            // verify required parameter 'paperPublishRequest' is not null or undefined
            assertParamExists('apiPapersPaperIdPublishPost', 'paperPublishRequest', paperPublishRequest)
            const localVarPath = `/api/papers/{paperId}/publish`
                .replace(`{${"paperId"}}`, encodeURIComponent(String(paperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paperPublishRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions for a paper with filters.
         * @param {string} paperId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersPaperIdVersionsGet: async (paperId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paperId' is not null or undefined
            assertParamExists('apiPapersPaperIdVersionsGet', 'paperId', paperId)
            const localVarPath = `/api/papers/{paperId}/versions`
                .replace(`{${"paperId"}}`, encodeURIComponent(String(paperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaperApi - functional programming interface
 * @export
 */
export const PaperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaperApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate paper via MT19937-driven auto assembly.
         * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPapersAutoPost(autoPaperCreateRequest: AutoPaperCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaperVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPapersAutoPost(autoPaperCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create manual paper draft and attach selected questions.
         * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPapersManualPost(manualPaperCreateRequest: ManualPaperCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaperVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPapersManualPost(manualPaperCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish paper version with activation window.
         * @param {string} paperId 
         * @param {PaperPublishRequest} paperPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPapersPaperIdPublishPost(paperId: string, paperPublishRequest: PaperPublishRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPapersPaperIdPublishPost(paperId, paperPublishRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions for a paper with filters.
         * @param {string} paperId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPapersPaperIdVersionsGet(paperId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaperVersionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPapersPaperIdVersionsGet(paperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaperApi - factory interface
 * @export
 */
export const PaperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaperApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate paper via MT19937-driven auto assembly.
         * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersAutoPost(autoPaperCreateRequest: AutoPaperCreateRequest, options?: any): AxiosPromise<PaperVersionResponse> {
            return localVarFp.apiPapersAutoPost(autoPaperCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create manual paper draft and attach selected questions.
         * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersManualPost(manualPaperCreateRequest: ManualPaperCreateRequest, options?: any): AxiosPromise<PaperVersionResponse> {
            return localVarFp.apiPapersManualPost(manualPaperCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish paper version with activation window.
         * @param {string} paperId 
         * @param {PaperPublishRequest} paperPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersPaperIdPublishPost(paperId: string, paperPublishRequest: PaperPublishRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiPapersPaperIdPublishPost(paperId, paperPublishRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions for a paper with filters.
         * @param {string} paperId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPapersPaperIdVersionsGet(paperId: string, options?: any): AxiosPromise<PaperVersionPage> {
            return localVarFp.apiPapersPaperIdVersionsGet(paperId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaperApi - object-oriented interface
 * @export
 * @class PaperApi
 * @extends {BaseAPI}
 */
export class PaperApi extends BaseAPI {
    /**
     * 
     * @summary Generate paper via MT19937-driven auto assembly.
     * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public apiPapersAutoPost(autoPaperCreateRequest: AutoPaperCreateRequest, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).apiPapersAutoPost(autoPaperCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create manual paper draft and attach selected questions.
     * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public apiPapersManualPost(manualPaperCreateRequest: ManualPaperCreateRequest, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).apiPapersManualPost(manualPaperCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish paper version with activation window.
     * @param {string} paperId 
     * @param {PaperPublishRequest} paperPublishRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public apiPapersPaperIdPublishPost(paperId: string, paperPublishRequest: PaperPublishRequest, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).apiPapersPaperIdPublishPost(paperId, paperPublishRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions for a paper with filters.
     * @param {string} paperId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public apiPapersPaperIdVersionsGet(paperId: string, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).apiPapersPaperIdVersionsGet(paperId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuestionBankApi - axios parameter creator
 * @export
 */
export const QuestionBankApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search questions in bank with multi-criteria filters.
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {string} [subjectId] 
         * @param {Array<string>} [knowledgePointIds] 
         * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
         * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
         * @param {string} [keywords] 
         * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsGet: async (page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/questions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            if (knowledgePointIds) {
                localVarQueryParameter['knowledgePointIds'] = knowledgePointIds.join(COLLECTION_FORMATS.csv);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Batch import questions via Word DOCX upload.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsImportDocxPost: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/questions/import/docx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new question (teacher or admin).
         * @param {QuestionCreateRequest} questionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsPost: async (questionCreateRequest: QuestionCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionCreateRequest' is not null or undefined
            assertParamExists('apiQuestionsPost', 'questionCreateRequest', questionCreateRequest)
            const localVarPath = `/api/questions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft-delete question (admin only, two-step confirmation).
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdDelete: async (questionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('apiQuestionsQuestionIdDelete', 'questionId', questionId)
            const localVarPath = `/api/questions/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch question by ID with revision history.
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdGet: async (questionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('apiQuestionsQuestionIdGet', 'questionId', questionId)
            const localVarPath = `/api/questions/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update question content (allowed for drafts or with admin override).
         * @param {string} questionId 
         * @param {QuestionUpdateRequest} questionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdPut: async (questionId: string, questionUpdateRequest: QuestionUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('apiQuestionsQuestionIdPut', 'questionId', questionId)
            // verify required parameter 'questionUpdateRequest' is not null or undefined
            assertParamExists('apiQuestionsQuestionIdPut', 'questionUpdateRequest', questionUpdateRequest)
            const localVarPath = `/api/questions/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve or reject question during audit workflow.
         * @param {string} questionId 
         * @param {QuestionReviewRequest} questionReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdReviewPost: async (questionId: string, questionReviewRequest: QuestionReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('apiQuestionsQuestionIdReviewPost', 'questionId', questionId)
            // verify required parameter 'questionReviewRequest' is not null or undefined
            assertParamExists('apiQuestionsQuestionIdReviewPost', 'questionReviewRequest', questionReviewRequest)
            const localVarPath = `/api/questions/{questionId}/review`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionBankApi - functional programming interface
 * @export
 */
export const QuestionBankApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionBankApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search questions in bank with multi-criteria filters.
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {string} [subjectId] 
         * @param {Array<string>} [knowledgePointIds] 
         * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
         * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
         * @param {string} [keywords] 
         * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsGet(page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsGet(page, size, subjectId, knowledgePointIds, type, difficulty, keywords, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Batch import questions via Word DOCX upload.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsImportDocxPost(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsImportDocxPost(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new question (teacher or admin).
         * @param {QuestionCreateRequest} questionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsPost(questionCreateRequest: QuestionCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsPost(questionCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Soft-delete question (admin only, two-step confirmation).
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsQuestionIdDelete(questionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsQuestionIdDelete(questionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch question by ID with revision history.
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsQuestionIdGet(questionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsQuestionIdGet(questionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update question content (allowed for drafts or with admin override).
         * @param {string} questionId 
         * @param {QuestionUpdateRequest} questionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsQuestionIdPut(questionId: string, questionUpdateRequest: QuestionUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsQuestionIdPut(questionId, questionUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Approve or reject question during audit workflow.
         * @param {string} questionId 
         * @param {QuestionReviewRequest} questionReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuestionsQuestionIdReviewPost(questionId: string, questionReviewRequest: QuestionReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuestionsQuestionIdReviewPost(questionId, questionReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuestionBankApi - factory interface
 * @export
 */
export const QuestionBankApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionBankApiFp(configuration)
    return {
        /**
         * 
         * @summary Search questions in bank with multi-criteria filters.
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {string} [subjectId] 
         * @param {Array<string>} [knowledgePointIds] 
         * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
         * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
         * @param {string} [keywords] 
         * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsGet(page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options?: any): AxiosPromise<QuestionPage> {
            return localVarFp.apiQuestionsGet(page, size, subjectId, knowledgePointIds, type, difficulty, keywords, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Batch import questions via Word DOCX upload.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsImportDocxPost(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.apiQuestionsImportDocxPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new question (teacher or admin).
         * @param {QuestionCreateRequest} questionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsPost(questionCreateRequest: QuestionCreateRequest, options?: any): AxiosPromise<QuestionResponse> {
            return localVarFp.apiQuestionsPost(questionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft-delete question (admin only, two-step confirmation).
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdDelete(questionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiQuestionsQuestionIdDelete(questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch question by ID with revision history.
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdGet(questionId: string, options?: any): AxiosPromise<QuestionResponse> {
            return localVarFp.apiQuestionsQuestionIdGet(questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update question content (allowed for drafts or with admin override).
         * @param {string} questionId 
         * @param {QuestionUpdateRequest} questionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdPut(questionId: string, questionUpdateRequest: QuestionUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiQuestionsQuestionIdPut(questionId, questionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve or reject question during audit workflow.
         * @param {string} questionId 
         * @param {QuestionReviewRequest} questionReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuestionsQuestionIdReviewPost(questionId: string, questionReviewRequest: QuestionReviewRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiQuestionsQuestionIdReviewPost(questionId, questionReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionBankApi - object-oriented interface
 * @export
 * @class QuestionBankApi
 * @extends {BaseAPI}
 */
export class QuestionBankApi extends BaseAPI {
    /**
     * 
     * @summary Search questions in bank with multi-criteria filters.
     * @param {number} [page] Zero-based page index.
     * @param {number} [size] Page size.
     * @param {string} [subjectId] 
     * @param {Array<string>} [knowledgePointIds] 
     * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
     * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
     * @param {string} [keywords] 
     * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsGet(page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'MULTIPLE_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsGet(page, size, subjectId, knowledgePointIds, type, difficulty, keywords, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Batch import questions via Word DOCX upload.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsImportDocxPost(file?: any, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsImportDocxPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new question (teacher or admin).
     * @param {QuestionCreateRequest} questionCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsPost(questionCreateRequest: QuestionCreateRequest, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsPost(questionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft-delete question (admin only, two-step confirmation).
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsQuestionIdDelete(questionId: string, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsQuestionIdDelete(questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch question by ID with revision history.
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsQuestionIdGet(questionId: string, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsQuestionIdGet(questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update question content (allowed for drafts or with admin override).
     * @param {string} questionId 
     * @param {QuestionUpdateRequest} questionUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsQuestionIdPut(questionId: string, questionUpdateRequest: QuestionUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsQuestionIdPut(questionId, questionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve or reject question during audit workflow.
     * @param {string} questionId 
     * @param {QuestionReviewRequest} questionReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public apiQuestionsQuestionIdReviewPost(questionId: string, questionReviewRequest: QuestionReviewRequest, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).apiQuestionsQuestionIdReviewPost(questionId, questionReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


