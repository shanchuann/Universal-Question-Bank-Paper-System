/* tslint:disable */
/* eslint-disable */
/**
 * Generalized Exam Item Bank & Paper Generation API
 * REST contract for RBAC-secured question management, paper assembly, online examination, and analytics services powering the Universal Question Bank Paper System.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthTokenResponse
 */
export interface AuthTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenResponse
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthTokenResponse
     */
    'expiresIn'?: number;
}
/**
 * 
 * @export
 * @interface AutoPaperCreateRequest
 */
export interface AutoPaperCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoPaperCreateRequest
     */
    'subjectId': string;
    /**
     * 
     * @type {string}
     * @memberof AutoPaperCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequest
     */
    'durationMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequest
     */
    'totalScore': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoPaperCreateRequest
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AutoPaperCreateRequest
     */
    'typeRatio': { [key: string]: number; };
    /**
     * 
     * @type {AutoPaperCreateRequestDifficultyDistribution}
     * @memberof AutoPaperCreateRequest
     */
    'difficultyDistribution': AutoPaperCreateRequestDifficultyDistribution;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoPaperCreateRequest
     */
    'exclusions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AutoPaperCreateRequestDifficultyDistribution
 */
export interface AutoPaperCreateRequestDifficultyDistribution {
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequestDifficultyDistribution
     */
    'EASY'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequestDifficultyDistribution
     */
    'MEDIUM'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoPaperCreateRequestDifficultyDistribution
     */
    'HARD'?: number;
}
/**
 * 
 * @export
 * @interface AutosaveRequest
 */
export interface AutosaveRequest {
    /**
     * 
     * @type {number}
     * @memberof AutosaveRequest
     */
    'sequence': number;
    /**
     * Snapshot of answers keyed by questionId.
     * @type {object}
     * @memberof AutosaveRequest
     */
    'payload': object;
    /**
     * 
     * @type {string}
     * @memberof AutosaveRequest
     */
    'clientTimestamp'?: string;
}
/**
 * 
 * @export
 * @interface ExamAnalyticsResponse
 */
export interface ExamAnalyticsResponse {
    /**
     * 
     * @type {string}
     * @memberof ExamAnalyticsResponse
     */
    'paperVersionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamAnalyticsResponse
     */
    'averageScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamAnalyticsResponse
     */
    'highestScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamAnalyticsResponse
     */
    'passRate'?: number;
    /**
     * 
     * @type {Array<ScoreBucket>}
     * @memberof ExamAnalyticsResponse
     */
    'scoreDistribution'?: Array<ScoreBucket>;
    /**
     * 
     * @type {Array<KnowledgeMetric>}
     * @memberof ExamAnalyticsResponse
     */
    'knowledgeMastery'?: Array<KnowledgeMetric>;
    /**
     * 
     * @type {Array<QuestionErrorRate>}
     * @memberof ExamAnalyticsResponse
     */
    'errorRates'?: Array<QuestionErrorRate>;
}
/**
 * 
 * @export
 * @interface ExamQuestion
 */
export interface ExamQuestion {
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'questionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'stem'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof ExamQuestion
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'userAnswer'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamQuestion
     */
    'awardedScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamQuestion
     */
    'graderNotes'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExamQuestion
     */
    'isCorrect'?: boolean;
}
/**
 * 
 * @export
 * @interface ExamSessionPage
 */
export interface ExamSessionPage {
    /**
     * 
     * @type {Array<ExamSessionResponse>}
     * @memberof ExamSessionPage
     */
    'content'?: Array<ExamSessionResponse>;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface ExamSessionResponse
 */
export interface ExamSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'paperVersionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionResponse
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'startAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExamSessionResponse
     */
    'endAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionResponse
     */
    'timeRemainingSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExamSessionResponse
     */
    'autosaveIntervalSeconds'?: number;
    /**
     * 
     * @type {Array<ExamQuestion>}
     * @memberof ExamSessionResponse
     */
    'questions'?: Array<ExamQuestion>;
}
/**
 * 
 * @export
 * @interface KnowledgeMetric
 */
export interface KnowledgeMetric {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeMetric
     */
    'knowledgePointId'?: string;
    /**
     * 
     * @type {number}
     * @memberof KnowledgeMetric
     */
    'masteryPercent'?: number;
}
/**
 * 
 * @export
 * @interface KnowledgePoint
 */
export interface KnowledgePoint {
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgePoint
     */
    'parentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof KnowledgePoint
     */
    'sortOrder'?: number;
    /**
     * 
     * @type {Array<KnowledgePoint>}
     * @memberof KnowledgePoint
     */
    'children'?: Array<KnowledgePoint>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ManualGradeRequest
 */
export interface ManualGradeRequest {
    /**
     * 
     * @type {Array<ManualGradeRequestGrades>}
     * @memberof ManualGradeRequest
     */
    'grades': Array<ManualGradeRequestGrades>;
}
/**
 * 
 * @export
 * @interface ManualGradeRequestGrades
 */
export interface ManualGradeRequestGrades {
    /**
     * 
     * @type {string}
     * @memberof ManualGradeRequestGrades
     */
    'questionId': string;
    /**
     * 
     * @type {number}
     * @memberof ManualGradeRequestGrades
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof ManualGradeRequestGrades
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface ManualPaperCreateRequest
 */
export interface ManualPaperCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ManualPaperCreateRequest
     */
    'subjectId': string;
    /**
     * 
     * @type {string}
     * @memberof ManualPaperCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperCreateRequest
     */
    'durationMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperCreateRequest
     */
    'totalScore'?: number;
    /**
     * 
     * @type {Array<ManualPaperQuestion>}
     * @memberof ManualPaperCreateRequest
     */
    'questions': Array<ManualPaperQuestion>;
}
/**
 * 
 * @export
 * @interface ManualPaperQuestion
 */
export interface ManualPaperQuestion {
    /**
     * 
     * @type {string}
     * @memberof ManualPaperQuestion
     */
    'questionId': string;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperQuestion
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof ManualPaperQuestion
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface PaperPublishRequest
 */
export interface PaperPublishRequest {
    /**
     * 
     * @type {string}
     * @memberof PaperPublishRequest
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof PaperPublishRequest
     */
    'activationStart': string;
    /**
     * 
     * @type {string}
     * @memberof PaperPublishRequest
     */
    'activationEnd': string;
    /**
     * 
     * @type {number}
     * @memberof PaperPublishRequest
     */
    'maxAttempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperPublishRequest
     */
    'autoSubmitGraceSeconds'?: number;
}
/**
 * 
 * @export
 * @interface PaperQuestionDetail
 */
export interface PaperQuestionDetail {
    /**
     * 
     * @type {string}
     * @memberof PaperQuestionDetail
     */
    'questionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaperQuestionDetail
     */
    'questionVersionNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperQuestionDetail
     */
    'position'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperQuestionDetail
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaperQuestionDetail
     */
    'difficulty'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaperQuestionDetail
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PaperVersionPage
 */
export interface PaperVersionPage {
    /**
     * 
     * @type {Array<PaperVersionResponse>}
     * @memberof PaperVersionPage
     */
    'content'?: Array<PaperVersionResponse>;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface PaperVersionResponse
 */
export interface PaperVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof PaperVersionResponse
     */
    'paperId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaperVersionResponse
     */
    'versionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaperVersionResponse
     */
    'assemblyMode'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'mtSeed'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'totalScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaperVersionResponse
     */
    'durationMinutes'?: number;
    /**
     * 
     * @type {Array<PaperQuestionDetail>}
     * @memberof PaperVersionResponse
     */
    'questions'?: Array<PaperQuestionDetail>;
}
/**
 * 
 * @export
 * @interface QuestionCreateRequest
 */
export interface QuestionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'subjectId': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'type': QuestionCreateRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'stem': string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionCreateRequest
     */
    'options'?: Array<QuestionOption>;
    /**
     * Machine-readable answer definition.
     * @type {object}
     * @memberof QuestionCreateRequest
     */
    'answerSchema': object;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'difficulty': QuestionCreateRequestDifficultyEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionCreateRequest
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof QuestionCreateRequest
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof QuestionCreateRequest
     */
    'mediaBundleId'?: string;
}

export const QuestionCreateRequestTypeEnum = {
    SingleChoice: 'SINGLE_CHOICE',
    MultiChoice: 'MULTI_CHOICE',
    TrueFalse: 'TRUE_FALSE',
    FillBlank: 'FILL_BLANK',
    ShortAnswer: 'SHORT_ANSWER'
} as const;

export type QuestionCreateRequestTypeEnum = typeof QuestionCreateRequestTypeEnum[keyof typeof QuestionCreateRequestTypeEnum];
export const QuestionCreateRequestDifficultyEnum = {
    Easy: 'EASY',
    Medium: 'MEDIUM',
    Hard: 'HARD'
} as const;

export type QuestionCreateRequestDifficultyEnum = typeof QuestionCreateRequestDifficultyEnum[keyof typeof QuestionCreateRequestDifficultyEnum];

/**
 * 
 * @export
 * @interface QuestionErrorRate
 */
export interface QuestionErrorRate {
    /**
     * 
     * @type {string}
     * @memberof QuestionErrorRate
     */
    'questionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'attempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'incorrect'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionErrorRate
     */
    'errorRate'?: number;
}
/**
 * 
 * @export
 * @interface QuestionOption
 */
export interface QuestionOption {
    /**
     * 
     * @type {string}
     * @memberof QuestionOption
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionOption
     */
    'text'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionOption
     */
    'isCorrect'?: boolean;
}
/**
 * 
 * @export
 * @interface QuestionPage
 */
export interface QuestionPage {
    /**
     * 
     * @type {Array<QuestionSummary>}
     * @memberof QuestionPage
     */
    'content'?: Array<QuestionSummary>;
    /**
     * 
     * @type {number}
     * @memberof QuestionPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface QuestionResponse
 */
export interface QuestionResponse {
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'subjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'stem'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'difficulty'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionResponse
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionResponse
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionResponse
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {object}
     * @memberof QuestionResponse
     */
    'answerSchema'?: object;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponse
     */
    'reviewer'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionResponse
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {Array<QuestionRevision>}
     * @memberof QuestionResponse
     */
    'history'?: Array<QuestionRevision>;
}
/**
 * 
 * @export
 * @interface QuestionResponseAllOf
 */
export interface QuestionResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseAllOf
     */
    'stem'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionResponseAllOf
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {object}
     * @memberof QuestionResponseAllOf
     */
    'answerSchema'?: object;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseAllOf
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionResponseAllOf
     */
    'reviewer'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionResponseAllOf
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {Array<QuestionRevision>}
     * @memberof QuestionResponseAllOf
     */
    'history'?: Array<QuestionRevision>;
}
/**
 * 
 * @export
 * @interface QuestionReviewRequest
 */
export interface QuestionReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionReviewRequest
     */
    'action': QuestionReviewRequestActionEnum;
    /**
     * 
     * @type {string}
     * @memberof QuestionReviewRequest
     */
    'notes'?: string;
}

export const QuestionReviewRequestActionEnum = {
    Approve: 'APPROVE',
    Reject: 'REJECT'
} as const;

export type QuestionReviewRequestActionEnum = typeof QuestionReviewRequestActionEnum[keyof typeof QuestionReviewRequestActionEnum];

/**
 * 
 * @export
 * @interface QuestionRevision
 */
export interface QuestionRevision {
    /**
     * 
     * @type {number}
     * @memberof QuestionRevision
     */
    'versionNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuestionRevision
     */
    'changedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionRevision
     */
    'changedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionRevision
     */
    'diffSummary'?: string;
}
/**
 * 
 * @export
 * @interface QuestionSummary
 */
export interface QuestionSummary {
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'subjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'stem'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'difficulty'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionSummary
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionSummary
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QuestionSummary
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface QuestionUpdateRequest
 */
export interface QuestionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'stem'?: string;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionUpdateRequest
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {object}
     * @memberof QuestionUpdateRequest
     */
    'answerSchema'?: object;
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'analysis'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionUpdateRequest
     */
    'difficulty'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionUpdateRequest
     */
    'knowledgePointIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof QuestionUpdateRequest
     */
    'score'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionUpdateRequest
     */
    'versionNumber'?: number;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ScoreBucket
 */
export interface ScoreBucket {
    /**
     * 
     * @type {string}
     * @memberof ScoreBucket
     */
    'range'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScoreBucket
     */
    'percentage'?: number;
}
/**
 * 
 * @export
 * @interface SubmissionResponse
 */
export interface SubmissionResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'submittedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof SubmissionResponse
     */
    'objectiveScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmissionResponse
     */
    'totalScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'status'?: SubmissionResponseStatusEnum;
}

export const SubmissionResponseStatusEnum = {
    Submitted: 'SUBMITTED',
    Timeout: 'TIMEOUT'
} as const;

export type SubmissionResponseStatusEnum = typeof SubmissionResponseStatusEnum[keyof typeof SubmissionResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserCreateRequest
 */
export interface UserCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCreateRequest
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserCreateRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserPage
 */
export interface UserPage {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof UserPage
     */
    'content'?: Array<UserResponse>;
    /**
     * 
     * @type {number}
     * @memberof UserPage
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPage
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponse
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List users with filtering options (admin only).
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
         * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create user with role assignments.
         * @param {UserCreateRequest} userCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (userCreateRequest: UserCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateRequest' is not null or undefined
            assertParamExists('usersPost', 'userCreateRequest', userCreateRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List users with filtering options (admin only).
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
         * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(page, size, role, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create user with role assignments.
         * @param {UserCreateRequest} userCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(userCreateRequest: UserCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(userCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary List users with filtering options (admin only).
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
         * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options?: any): AxiosPromise<UserPage> {
            return localVarFp.usersGet(page, size, role, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create user with role assignments.
         * @param {UserCreateRequest} userCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(userCreateRequest: UserCreateRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.usersPost(userCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary List users with filtering options (admin only).
     * @param {number} [page] Zero-based page index.
     * @param {number} [size] Page size.
     * @param {'ADMIN' | 'TEACHER' | 'STUDENT'} [role] 
     * @param {'ACTIVE' | 'LOCKED' | 'INVITED'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersGet(page?: number, size?: number, role?: 'ADMIN' | 'TEACHER' | 'STUDENT', status?: 'ACTIVE' | 'LOCKED' | 'INVITED', options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersGet(page, size, role, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create user with role assignments.
     * @param {UserCreateRequest} userCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public usersPost(userCreateRequest: UserCreateRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).usersPost(userCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
         * @param {string} paperVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsExamsPaperVersionIdSummaryGet: async (paperVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paperVersionId' is not null or undefined
            assertParamExists('analyticsExamsPaperVersionIdSummaryGet', 'paperVersionId', paperVersionId)
            const localVarPath = `/analytics/exams/{paperVersionId}/summary`
                .replace(`{${"paperVersionId"}}`, encodeURIComponent(String(paperVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compute top N questions by error rate across selected timeframe.
         * @param {string} [subjectId] 
         * @param {string} [knowledgePointId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsQuestionsErrorRateGet: async (subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/questions/error-rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            if (knowledgePointId !== undefined) {
                localVarQueryParameter['knowledgePointId'] = knowledgePointId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
         * @param {string} paperVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsExamsPaperVersionIdSummaryGet(paperVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsExamsPaperVersionIdSummaryGet(paperVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Compute top N questions by error rate across selected timeframe.
         * @param {string} [subjectId] 
         * @param {string} [knowledgePointId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsQuestionsErrorRateGet(subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionErrorRate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsQuestionsErrorRateGet(subjectId, knowledgePointId, startDate, endDate, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
         * @param {string} paperVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsExamsPaperVersionIdSummaryGet(paperVersionId: string, options?: any): AxiosPromise<ExamAnalyticsResponse> {
            return localVarFp.analyticsExamsPaperVersionIdSummaryGet(paperVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compute top N questions by error rate across selected timeframe.
         * @param {string} [subjectId] 
         * @param {string} [knowledgePointId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsQuestionsErrorRateGet(subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options?: any): AxiosPromise<Array<QuestionErrorRate>> {
            return localVarFp.analyticsQuestionsErrorRateGet(subjectId, knowledgePointId, startDate, endDate, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch score distribution, pass rate, and knowledge mastery metrics.
     * @param {string} paperVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsExamsPaperVersionIdSummaryGet(paperVersionId: string, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsExamsPaperVersionIdSummaryGet(paperVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compute top N questions by error rate across selected timeframe.
     * @param {string} [subjectId] 
     * @param {string} [knowledgePointId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public analyticsQuestionsErrorRateGet(subjectId?: string, knowledgePointId?: string, startDate?: string, endDate?: string, limit?: number, options?: AxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).analyticsQuestionsErrorRateGet(subjectId, knowledgePointId, startDate, endDate, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate user via username/password.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh JWT access token.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshPost: async (refreshTokenRequest: RefreshTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('authTokenRefreshPost', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate user via username/password.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh JWT access token.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRefreshPost(refreshTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate user via username/password.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthTokenResponse> {
            return localVarFp.authLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh JWT access token.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: any): AxiosPromise<AuthTokenResponse> {
            return localVarFp.authTokenRefreshPost(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate user via username/password.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh JWT access token.
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRefreshPost(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExamApi - axios parameter creator
 * @export
 */
export const ExamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Validate access code and start exam session.
         * @param {string} accessCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsAccessCodeStartPost: async (accessCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessCode' is not null or undefined
            assertParamExists('examsAccessCodeStartPost', 'accessCode', accessCode)
            const localVarPath = `/exams/{accessCode}/start`
                .replace(`{${"accessCode"}}`, encodeURIComponent(String(accessCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List exam sessions (for grading).
         * @param {string} [paperId] 
         * @param {string} [userId] 
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsGet: async (paperId?: string, userId?: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (paperId !== undefined) {
                localVarQueryParameter['paperId'] = paperId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get exam session details.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('examsIdGet', 'id', id)
            const localVarPath = `/exams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Persist autosave snapshot (30s cadence).
         * @param {string} sessionId 
         * @param {AutosaveRequest} autosaveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdAutosavePost: async (sessionId: string, autosaveRequest: AutosaveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('examsSessionIdAutosavePost', 'sessionId', sessionId)
            // verify required parameter 'autosaveRequest' is not null or undefined
            assertParamExists('examsSessionIdAutosavePost', 'autosaveRequest', autosaveRequest)
            const localVarPath = `/exams/{sessionId}/autosave`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autosaveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record manual grades for subjective questions.
         * @param {string} sessionId 
         * @param {ManualGradeRequest} manualGradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdGradePost: async (sessionId: string, manualGradeRequest: ManualGradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('examsSessionIdGradePost', 'sessionId', sessionId)
            // verify required parameter 'manualGradeRequest' is not null or undefined
            assertParamExists('examsSessionIdGradePost', 'manualGradeRequest', manualGradeRequest)
            const localVarPath = `/exams/{sessionId}/grade`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualGradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Maintain active session and sync time remaining.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdHeartbeatPost: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('examsSessionIdHeartbeatPost', 'sessionId', sessionId)
            const localVarPath = `/exams/{sessionId}/heartbeat`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit exam (voluntary or timeout).
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdSubmitPost: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('examsSessionIdSubmitPost', 'sessionId', sessionId)
            const localVarPath = `/exams/{sessionId}/submit`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExamApi - functional programming interface
 * @export
 */
export const ExamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Validate access code and start exam session.
         * @param {string} accessCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsAccessCodeStartPost(accessCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsAccessCodeStartPost(accessCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List exam sessions (for grading).
         * @param {string} [paperId] 
         * @param {string} [userId] 
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsGet(paperId?: string, userId?: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamSessionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsGet(paperId, userId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get exam session details.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExamSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Persist autosave snapshot (30s cadence).
         * @param {string} sessionId 
         * @param {AutosaveRequest} autosaveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsSessionIdAutosavePost(sessionId: string, autosaveRequest: AutosaveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsSessionIdAutosavePost(sessionId, autosaveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record manual grades for subjective questions.
         * @param {string} sessionId 
         * @param {ManualGradeRequest} manualGradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsSessionIdGradePost(sessionId: string, manualGradeRequest: ManualGradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsSessionIdGradePost(sessionId, manualGradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Maintain active session and sync time remaining.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsSessionIdHeartbeatPost(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsSessionIdHeartbeatPost(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit exam (voluntary or timeout).
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async examsSessionIdSubmitPost(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.examsSessionIdSubmitPost(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExamApi - factory interface
 * @export
 */
export const ExamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExamApiFp(configuration)
    return {
        /**
         * 
         * @summary Validate access code and start exam session.
         * @param {string} accessCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsAccessCodeStartPost(accessCode: string, options?: any): AxiosPromise<ExamSessionResponse> {
            return localVarFp.examsAccessCodeStartPost(accessCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List exam sessions (for grading).
         * @param {string} [paperId] 
         * @param {string} [userId] 
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsGet(paperId?: string, userId?: string, page?: number, size?: number, options?: any): AxiosPromise<ExamSessionPage> {
            return localVarFp.examsGet(paperId, userId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get exam session details.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsIdGet(id: string, options?: any): AxiosPromise<ExamSessionResponse> {
            return localVarFp.examsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Persist autosave snapshot (30s cadence).
         * @param {string} sessionId 
         * @param {AutosaveRequest} autosaveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdAutosavePost(sessionId: string, autosaveRequest: AutosaveRequest, options?: any): AxiosPromise<void> {
            return localVarFp.examsSessionIdAutosavePost(sessionId, autosaveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record manual grades for subjective questions.
         * @param {string} sessionId 
         * @param {ManualGradeRequest} manualGradeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdGradePost(sessionId: string, manualGradeRequest: ManualGradeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.examsSessionIdGradePost(sessionId, manualGradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Maintain active session and sync time remaining.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdHeartbeatPost(sessionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.examsSessionIdHeartbeatPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit exam (voluntary or timeout).
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examsSessionIdSubmitPost(sessionId: string, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.examsSessionIdSubmitPost(sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExamApi - object-oriented interface
 * @export
 * @class ExamApi
 * @extends {BaseAPI}
 */
export class ExamApi extends BaseAPI {
    /**
     * 
     * @summary Validate access code and start exam session.
     * @param {string} accessCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsAccessCodeStartPost(accessCode: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsAccessCodeStartPost(accessCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List exam sessions (for grading).
     * @param {string} [paperId] 
     * @param {string} [userId] 
     * @param {number} [page] Zero-based page index.
     * @param {number} [size] Page size.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsGet(paperId?: string, userId?: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsGet(paperId, userId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get exam session details.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsIdGet(id: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Persist autosave snapshot (30s cadence).
     * @param {string} sessionId 
     * @param {AutosaveRequest} autosaveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsSessionIdAutosavePost(sessionId: string, autosaveRequest: AutosaveRequest, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsSessionIdAutosavePost(sessionId, autosaveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record manual grades for subjective questions.
     * @param {string} sessionId 
     * @param {ManualGradeRequest} manualGradeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsSessionIdGradePost(sessionId: string, manualGradeRequest: ManualGradeRequest, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsSessionIdGradePost(sessionId, manualGradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Maintain active session and sync time remaining.
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsSessionIdHeartbeatPost(sessionId: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsSessionIdHeartbeatPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit exam (voluntary or timeout).
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExamApi
     */
    public examsSessionIdSubmitPost(sessionId: string, options?: AxiosRequestConfig) {
        return ExamApiFp(this.configuration).examsSessionIdSubmitPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KnowledgePointApi - axios parameter creator
 * @export
 */
export const KnowledgePointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all knowledge points as a tree structure.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/knowledge-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a knowledge point.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgePointsIdDelete', 'id', id)
            const localVarPath = `/knowledge-points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a knowledge point.
         * @param {string} id 
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsIdPut: async (id: string, knowledgePoint: KnowledgePoint, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgePointsIdPut', 'id', id)
            // verify required parameter 'knowledgePoint' is not null or undefined
            assertParamExists('knowledgePointsIdPut', 'knowledgePoint', knowledgePoint)
            const localVarPath = `/knowledge-points/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(knowledgePoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new knowledge point.
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsPost: async (knowledgePoint: KnowledgePoint, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'knowledgePoint' is not null or undefined
            assertParamExists('knowledgePointsPost', 'knowledgePoint', knowledgePoint)
            const localVarPath = `/knowledge-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(knowledgePoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgePointApi - functional programming interface
 * @export
 */
export const KnowledgePointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgePointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all knowledge points as a tree structure.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgePointsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KnowledgePoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgePointsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a knowledge point.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgePointsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgePointsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a knowledge point.
         * @param {string} id 
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgePointsIdPut(id: string, knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgePointsIdPut(id, knowledgePoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new knowledge point.
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgePointsPost(knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgePoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgePointsPost(knowledgePoint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KnowledgePointApi - factory interface
 * @export
 */
export const KnowledgePointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgePointApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all knowledge points as a tree structure.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsGet(options?: any): AxiosPromise<Array<KnowledgePoint>> {
            return localVarFp.knowledgePointsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a knowledge point.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.knowledgePointsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a knowledge point.
         * @param {string} id 
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsIdPut(id: string, knowledgePoint: KnowledgePoint, options?: any): AxiosPromise<KnowledgePoint> {
            return localVarFp.knowledgePointsIdPut(id, knowledgePoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new knowledge point.
         * @param {KnowledgePoint} knowledgePoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgePointsPost(knowledgePoint: KnowledgePoint, options?: any): AxiosPromise<KnowledgePoint> {
            return localVarFp.knowledgePointsPost(knowledgePoint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KnowledgePointApi - object-oriented interface
 * @export
 * @class KnowledgePointApi
 * @extends {BaseAPI}
 */
export class KnowledgePointApi extends BaseAPI {
    /**
     * 
     * @summary Get all knowledge points as a tree structure.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public knowledgePointsGet(options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).knowledgePointsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a knowledge point.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public knowledgePointsIdDelete(id: string, options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).knowledgePointsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a knowledge point.
     * @param {string} id 
     * @param {KnowledgePoint} knowledgePoint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public knowledgePointsIdPut(id: string, knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).knowledgePointsIdPut(id, knowledgePoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new knowledge point.
     * @param {KnowledgePoint} knowledgePoint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgePointApi
     */
    public knowledgePointsPost(knowledgePoint: KnowledgePoint, options?: AxiosRequestConfig) {
        return KnowledgePointApiFp(this.configuration).knowledgePointsPost(knowledgePoint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaperApi - axios parameter creator
 * @export
 */
export const PaperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate paper via MT19937-driven auto assembly.
         * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersAutoPost: async (autoPaperCreateRequest: AutoPaperCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoPaperCreateRequest' is not null or undefined
            assertParamExists('papersAutoPost', 'autoPaperCreateRequest', autoPaperCreateRequest)
            const localVarPath = `/papers/auto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoPaperCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create manual paper draft and attach selected questions.
         * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersManualPost: async (manualPaperCreateRequest: ManualPaperCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manualPaperCreateRequest' is not null or undefined
            assertParamExists('papersManualPost', 'manualPaperCreateRequest', manualPaperCreateRequest)
            const localVarPath = `/papers/manual`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualPaperCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish paper version with activation window.
         * @param {string} paperId 
         * @param {PaperPublishRequest} paperPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersPaperIdPublishPost: async (paperId: string, paperPublishRequest: PaperPublishRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paperId' is not null or undefined
            assertParamExists('papersPaperIdPublishPost', 'paperId', paperId)
            // verify required parameter 'paperPublishRequest' is not null or undefined
            assertParamExists('papersPaperIdPublishPost', 'paperPublishRequest', paperPublishRequest)
            const localVarPath = `/papers/{paperId}/publish`
                .replace(`{${"paperId"}}`, encodeURIComponent(String(paperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paperPublishRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions for a paper with filters.
         * @param {string} paperId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersPaperIdVersionsGet: async (paperId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paperId' is not null or undefined
            assertParamExists('papersPaperIdVersionsGet', 'paperId', paperId)
            const localVarPath = `/papers/{paperId}/versions`
                .replace(`{${"paperId"}}`, encodeURIComponent(String(paperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaperApi - functional programming interface
 * @export
 */
export const PaperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaperApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate paper via MT19937-driven auto assembly.
         * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async papersAutoPost(autoPaperCreateRequest: AutoPaperCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaperVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.papersAutoPost(autoPaperCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create manual paper draft and attach selected questions.
         * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async papersManualPost(manualPaperCreateRequest: ManualPaperCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaperVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.papersManualPost(manualPaperCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Publish paper version with activation window.
         * @param {string} paperId 
         * @param {PaperPublishRequest} paperPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async papersPaperIdPublishPost(paperId: string, paperPublishRequest: PaperPublishRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.papersPaperIdPublishPost(paperId, paperPublishRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions for a paper with filters.
         * @param {string} paperId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async papersPaperIdVersionsGet(paperId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaperVersionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.papersPaperIdVersionsGet(paperId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaperApi - factory interface
 * @export
 */
export const PaperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaperApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate paper via MT19937-driven auto assembly.
         * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersAutoPost(autoPaperCreateRequest: AutoPaperCreateRequest, options?: any): AxiosPromise<PaperVersionResponse> {
            return localVarFp.papersAutoPost(autoPaperCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create manual paper draft and attach selected questions.
         * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersManualPost(manualPaperCreateRequest: ManualPaperCreateRequest, options?: any): AxiosPromise<PaperVersionResponse> {
            return localVarFp.papersManualPost(manualPaperCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish paper version with activation window.
         * @param {string} paperId 
         * @param {PaperPublishRequest} paperPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersPaperIdPublishPost(paperId: string, paperPublishRequest: PaperPublishRequest, options?: any): AxiosPromise<void> {
            return localVarFp.papersPaperIdPublishPost(paperId, paperPublishRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions for a paper with filters.
         * @param {string} paperId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        papersPaperIdVersionsGet(paperId: string, options?: any): AxiosPromise<PaperVersionPage> {
            return localVarFp.papersPaperIdVersionsGet(paperId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaperApi - object-oriented interface
 * @export
 * @class PaperApi
 * @extends {BaseAPI}
 */
export class PaperApi extends BaseAPI {
    /**
     * 
     * @summary Generate paper via MT19937-driven auto assembly.
     * @param {AutoPaperCreateRequest} autoPaperCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public papersAutoPost(autoPaperCreateRequest: AutoPaperCreateRequest, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).papersAutoPost(autoPaperCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create manual paper draft and attach selected questions.
     * @param {ManualPaperCreateRequest} manualPaperCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public papersManualPost(manualPaperCreateRequest: ManualPaperCreateRequest, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).papersManualPost(manualPaperCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish paper version with activation window.
     * @param {string} paperId 
     * @param {PaperPublishRequest} paperPublishRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public papersPaperIdPublishPost(paperId: string, paperPublishRequest: PaperPublishRequest, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).papersPaperIdPublishPost(paperId, paperPublishRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions for a paper with filters.
     * @param {string} paperId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaperApi
     */
    public papersPaperIdVersionsGet(paperId: string, options?: AxiosRequestConfig) {
        return PaperApiFp(this.configuration).papersPaperIdVersionsGet(paperId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuestionBankApi - axios parameter creator
 * @export
 */
export const QuestionBankApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search questions in bank with multi-criteria filters.
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {string} [subjectId] 
         * @param {Array<string>} [knowledgePointIds] 
         * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
         * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
         * @param {string} [keywords] 
         * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsGet: async (page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            if (knowledgePointIds) {
                localVarQueryParameter['knowledgePointIds'] = knowledgePointIds.join(COLLECTION_FORMATS.csv);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (difficulty !== undefined) {
                localVarQueryParameter['difficulty'] = difficulty;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Batch import questions via Word DOCX upload.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsImportDocxPost: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questions/import/docx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new question (teacher or admin).
         * @param {QuestionCreateRequest} questionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsPost: async (questionCreateRequest: QuestionCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionCreateRequest' is not null or undefined
            assertParamExists('questionsPost', 'questionCreateRequest', questionCreateRequest)
            const localVarPath = `/questions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Soft-delete question (admin only, two-step confirmation).
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdDelete: async (questionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsQuestionIdDelete', 'questionId', questionId)
            const localVarPath = `/questions/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch question by ID with revision history.
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdGet: async (questionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsQuestionIdGet', 'questionId', questionId)
            const localVarPath = `/questions/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update question content (allowed for drafts or with admin override).
         * @param {string} questionId 
         * @param {QuestionUpdateRequest} questionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdPut: async (questionId: string, questionUpdateRequest: QuestionUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsQuestionIdPut', 'questionId', questionId)
            // verify required parameter 'questionUpdateRequest' is not null or undefined
            assertParamExists('questionsQuestionIdPut', 'questionUpdateRequest', questionUpdateRequest)
            const localVarPath = `/questions/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve or reject question during audit workflow.
         * @param {string} questionId 
         * @param {QuestionReviewRequest} questionReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdReviewPost: async (questionId: string, questionReviewRequest: QuestionReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('questionsQuestionIdReviewPost', 'questionId', questionId)
            // verify required parameter 'questionReviewRequest' is not null or undefined
            assertParamExists('questionsQuestionIdReviewPost', 'questionReviewRequest', questionReviewRequest)
            const localVarPath = `/questions/{questionId}/review`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionBankApi - functional programming interface
 * @export
 */
export const QuestionBankApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionBankApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search questions in bank with multi-criteria filters.
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {string} [subjectId] 
         * @param {Array<string>} [knowledgePointIds] 
         * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
         * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
         * @param {string} [keywords] 
         * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsGet(page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsGet(page, size, subjectId, knowledgePointIds, type, difficulty, keywords, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Batch import questions via Word DOCX upload.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsImportDocxPost(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsImportDocxPost(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new question (teacher or admin).
         * @param {QuestionCreateRequest} questionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsPost(questionCreateRequest: QuestionCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsPost(questionCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Soft-delete question (admin only, two-step confirmation).
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsQuestionIdDelete(questionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsQuestionIdDelete(questionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch question by ID with revision history.
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsQuestionIdGet(questionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsQuestionIdGet(questionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update question content (allowed for drafts or with admin override).
         * @param {string} questionId 
         * @param {QuestionUpdateRequest} questionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsQuestionIdPut(questionId: string, questionUpdateRequest: QuestionUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsQuestionIdPut(questionId, questionUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Approve or reject question during audit workflow.
         * @param {string} questionId 
         * @param {QuestionReviewRequest} questionReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async questionsQuestionIdReviewPost(questionId: string, questionReviewRequest: QuestionReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.questionsQuestionIdReviewPost(questionId, questionReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuestionBankApi - factory interface
 * @export
 */
export const QuestionBankApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionBankApiFp(configuration)
    return {
        /**
         * 
         * @summary Search questions in bank with multi-criteria filters.
         * @param {number} [page] Zero-based page index.
         * @param {number} [size] Page size.
         * @param {string} [subjectId] 
         * @param {Array<string>} [knowledgePointIds] 
         * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
         * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
         * @param {string} [keywords] 
         * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsGet(page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options?: any): AxiosPromise<QuestionPage> {
            return localVarFp.questionsGet(page, size, subjectId, knowledgePointIds, type, difficulty, keywords, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Batch import questions via Word DOCX upload.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsImportDocxPost(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.questionsImportDocxPost(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new question (teacher or admin).
         * @param {QuestionCreateRequest} questionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsPost(questionCreateRequest: QuestionCreateRequest, options?: any): AxiosPromise<QuestionResponse> {
            return localVarFp.questionsPost(questionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Soft-delete question (admin only, two-step confirmation).
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdDelete(questionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.questionsQuestionIdDelete(questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch question by ID with revision history.
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdGet(questionId: string, options?: any): AxiosPromise<QuestionResponse> {
            return localVarFp.questionsQuestionIdGet(questionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update question content (allowed for drafts or with admin override).
         * @param {string} questionId 
         * @param {QuestionUpdateRequest} questionUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdPut(questionId: string, questionUpdateRequest: QuestionUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.questionsQuestionIdPut(questionId, questionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve or reject question during audit workflow.
         * @param {string} questionId 
         * @param {QuestionReviewRequest} questionReviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        questionsQuestionIdReviewPost(questionId: string, questionReviewRequest: QuestionReviewRequest, options?: any): AxiosPromise<void> {
            return localVarFp.questionsQuestionIdReviewPost(questionId, questionReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionBankApi - object-oriented interface
 * @export
 * @class QuestionBankApi
 * @extends {BaseAPI}
 */
export class QuestionBankApi extends BaseAPI {
    /**
     * 
     * @summary Search questions in bank with multi-criteria filters.
     * @param {number} [page] Zero-based page index.
     * @param {number} [size] Page size.
     * @param {string} [subjectId] 
     * @param {Array<string>} [knowledgePointIds] 
     * @param {'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER'} [type] 
     * @param {'EASY' | 'MEDIUM' | 'HARD'} [difficulty] 
     * @param {string} [keywords] 
     * @param {'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED'} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsGet(page?: number, size?: number, subjectId?: string, knowledgePointIds?: Array<string>, type?: 'SINGLE_CHOICE' | 'MULTI_CHOICE' | 'TRUE_FALSE' | 'FILL_BLANK' | 'SHORT_ANSWER', difficulty?: 'EASY' | 'MEDIUM' | 'HARD', keywords?: string, status?: 'DRAFT' | 'PENDING_REVIEW' | 'APPROVED' | 'ARCHIVED', options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsGet(page, size, subjectId, knowledgePointIds, type, difficulty, keywords, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Batch import questions via Word DOCX upload.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsImportDocxPost(file?: any, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsImportDocxPost(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new question (teacher or admin).
     * @param {QuestionCreateRequest} questionCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsPost(questionCreateRequest: QuestionCreateRequest, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsPost(questionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Soft-delete question (admin only, two-step confirmation).
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsQuestionIdDelete(questionId: string, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsQuestionIdDelete(questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch question by ID with revision history.
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsQuestionIdGet(questionId: string, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsQuestionIdGet(questionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update question content (allowed for drafts or with admin override).
     * @param {string} questionId 
     * @param {QuestionUpdateRequest} questionUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsQuestionIdPut(questionId: string, questionUpdateRequest: QuestionUpdateRequest, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsQuestionIdPut(questionId, questionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve or reject question during audit workflow.
     * @param {string} questionId 
     * @param {QuestionReviewRequest} questionReviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionBankApi
     */
    public questionsQuestionIdReviewPost(questionId: string, questionReviewRequest: QuestionReviewRequest, options?: AxiosRequestConfig) {
        return QuestionBankApiFp(this.configuration).questionsQuestionIdReviewPost(questionId, questionReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


